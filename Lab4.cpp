
/*************************************************************
	Практическое занятие №3. Функции.
	Объявление, определение, вызов.
	Передача параметров. Возвращение значения.
	Указатели на функции
*************************************************************/
#include <iostream>
#include <tchar.h>
//#include <cstdio>
//#include <cstdarg>
#include "other.h"
#include "vld.h"


#define	  stop __asm nop

int _tmain()
{
	
	/////////////////////////////////////////////////////////////////////////////
	// Задание 1. Ссылки.
	//Объявите ссылку на тип double. Посредством ссылки измените значение
	std::cout << "#1" << std::endl;
	double n = 2;
	double& r = n;
	r = 4;
	std::cout << "n="<<n;
	std::cout << std::endl;

	//Раскомментируйте  следующую строчку. Что следует сделать, чтобы
	//linker не выдавал ошибки при создании exe-файла. Подсказка: ref - это
	//внешняя по отношению к данному файлу ссылка!
	//extern!
	ref++;
	std::cout << "ref="<<ref;
	std::cout << std::endl;



	//Раскомментируйте следующую строку. Что следует сделать, чтобы
	//компилятор не выдавал ошибки 
	const int& ref1 = 1;//дописала константу



	//Задан указатель:
	std::cout << "ssilka na ukazatel'" << std::endl;
	char c='A';
	char* pc = &c;
	char nc = 6;
	char* pnc = &nc;
	//Объявите ссылку на указатель. Посредством ссылки измените
	//а) значение по адресу
	//б) сам адрес//Ссылка содержит адрес, но этот адрес формируется один раз при инициализации и изменить его невозможно!
	char*& refP = pc;
	std::cout << *refP;
	std::cout << std::endl;
	*refP = 'B';
	std::cout << *refP;
	std::cout << std::endl;

	
	std::cout << "#2" << std::endl;
	//Задание 2. Отличия при передаче параметров а) по значению,
	// б) по ссылке, в) по указателю
	//Объявите и определите три функции , которые увеличивают заданное
	//с помощью параметра значение на 1 ( а) - IncByValue(),
	// б) - IncByPointer(), в) - IncByReference() ). 
	//Проверьте правильность с помощью отладчика.
	//
	//Замечание: объявления функций принято помещать в заголовочный файл
	int val =1;//значение этой переменной должно быть увеличено с помощью
				//каждой из функций на единицу
	int r1 = IncByValue(val) + 3;
	int r2 = IncByPointer(&val);
	int r3 = IncByReference(val);	stop
	std::cout << r1 << ' ' << r2 << ' ' << r3 << std::endl;

	//Задание 2а. Передача параметров c помощью указателя и по ссылке. 
	//Перегруженные имена функций.
	//Создайте функцию (функции) Swap(), которая меняет значения
	//переменных nX и nY местами. 
	// а)Функция должна принимать два указателя на int, оперируя с 
	//которыми менять значения переменных в вызывающей программе
	// б)Функция должна принимать две ссылки на int 
	//Проверьте правильность с помощью приведенного ниже фрагмента.
	{std::cout << "#2a" << std::endl;
	int	nX = 1;
	int nY = -1;
	std::cout << "iznachal'no:\n" << nX << ' ' << nY << std::endl;
	Swap(&nX, &nY);	//поменяли местами значения nX и nY с
	std::cout << "1 smena:\n" << nX << ' ' << nY << std::endl;				//помощью указателей на nX и nY
	Swap(nX, nY);	//а теперь обратно с помощью ссылок на nX и nY
	std::cout << "2 smena:\n" << nX << ' ' << nY << std::endl;
	stop
	}

		//Задание 3. Указатели на массивы в качестве аргументов.
		//3a.Напишите два варианта функции поиска минимального элемента
		//1. во встроенном двухмерном массиве
		//2. в динамическом двухмерном массиве (обе размерности вычисляются)

		//1.Например:
	std::cout << "#3" << std::endl;
	{ int ar[N][M] = { {34,667,21,92},{56,80,40,1},{6,34,2,0},{45,32,87,499},{456,398,-102,89},{54,29,38,74} };//подумайте - как и где должны быть заданы N и M
	int res = Min(ar); // может быть, понадобится передать еще какие-нибудь данные); 
	std::cout << res<<std::endl;

	int size1 = 6;
	int size2 = 4;
	int** c = new int* [size1];
	for (int i = 0; i < size1; i++) {
		c[i] = new int[size2];
	}
	full(c, size1, size2);
	int r = Min(c, size1, size2);
	std::cout << r << std::endl;
	for (int i = 0; i < size1; i++) {
		delete[] c[i];
	}
	delete[] c;
	}


	//3b. Напишите функцию сравнения двух строк - MyStrCmp():
	//Функция должна принимать два указателя на сравниваемые
	//строки (возможно Вы должны указать компилятору, что функция
	//не имеет права модифицировать содержимое строк)
	//Функция должна возвращать отрицательное значение, если
	//первая строка лексиграфически меньше второй, 0 - если
	//они равны и положительное значение, если первая строка
	//больше второй.
	//Вспомните, что признаком конца строки является нулевой байт.
	std::cout<<"#3b" << std::endl;
	
	//Создайте две строки для сравнения: 
	char str1[5] = "kbc";
	char str2[6] = "dbf";
	//Вызовите функцию сравнения
	r = MyStrCmp(str1, str2);
	//Выведите результат сравнения с помощью cout:
	std::cout << r << std::endl;
	std::cout << std::endl;
	stop;


	//Задание 4.Ссылки в качестве параметров. Передача указателя на встроенный
	//массив в качестве параметра функции.
	//Напишите две взаимодополняющие друг друга функции:
	//1.  ... DayOfYear(...)
	//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
	//в порядковый день года(возвращаемое значение)
	//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
	// (принимает год и порядковый день года в качестве параметров и должна сформировать
	// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)
	
	//Проверьте работоспособность обеих функций с помощью следующего фрагмента:
	

	//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
	//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
	//данные приведенного ниже двухмерного массива nDayTab
	std::cout << "#4" << std::endl;
	int nDayTab[2][12]={
		{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
		{31,29,31,30,31,30,31,31,30,31,30,31}	};	//високосный год
	int day = 7;
	int month = 4;
	int year = 2000;
	bool isLeapYear(year);

	//Вызов функции DayOfYear
	//...
	std::cout << DayOfYear(day, month, year, nDayTab) << std::endl;

	//Проверка результата обратной функцией DayOfMonth
	//...
	std::tie(day, month) = DayOfMonth(DayOfYear(day, month, year, nDayTab), month, year, nDayTab);
	std::cout << day<< " "<< month << std::endl;
	stop

		//Задание 5. Создайте одномерный массив (размерность вычисляется в процессе
		//выполнения программы), заполните его значениями.
		//Напишите функцию, которая добавляет в массив новое значение только при условии,
		//что такого значения в массиве еще нет. Подсказка: при этом размер
		//массива должен увеличиться!
		//Для проверки напишите функцию, которая выводит значения всех элементов на экран

	{   
		std::cout << "#5" << std::endl;
		int n;
	    int k;
		std::cout << "Insert value:" << std::endl;
		std::cin >> n;
		std::cout << std::endl;
		int* arr = new int[n];
		std::cout << "\nArray before:\t";
		full(arr, n);
		std::cout << std::endl;
		std::cout << "new num:\t";
		std::cin>> k;
		std::cout << "\nArray after:\t";
		addition(arr, n, k);
		std::cout << std::endl;
		delete[] arr;
	}

		//Задание 6. Рекурсивные функции. Напишите рекурсивную функцию вычисления
		//суммы первых N натуральных чисел.
	{   
		std::cout << "#6" << std::endl;
		int n = 6;
		std::cout << "\nSum of first " << n << " numbers = " << sumFirstN(n) << std::endl;
		std::cout << std::endl;
	}




	//Задание 7а. Функции с переменным числом параметров.
	//Напишите функцию (дана заготовка VarArgs, не использующая
	// макросы), которая принимает переменное число аргументов
	// типа int и выводит на печать число принятых параметров и
	// их значения.
	// Признаком конца списка является нулевое значение.
	std::cout << "#7a" << std::endl;
	int nN1=5, nN2=11, nN3=4, nN4=7, nN5=-1;
	VarArgs(nN1,0);	
	VarArgs(nN1,nN2,0);	
	VarArgs(nN1,nN2,nN3,nN4,nN5,0);	
	std::cout << std::endl;
	stop


		//Задание 7б. Модифицируйте функцию 7а с помощью макросов
		//va_start, va_arg, va_end

	{
	std::cout << "#7b" << std::endl;
	int nN1 = 5, nN2 = 11, nN3 = 4, nN4 = 7, nN5 = -1;
	VarArgsM(nN1, 0);
	VarArgsM(nN1, nN2, 0);
	VarArgsM(nN1, nN2, nN3, nN4, nN5, 0);
	std::cout << std::endl;
	}



	//Задание 8. Возвращение адреса.
	//Напишите функцию, которая находит минимальное значение в массиве,
	// таким образом, чтобы ее вызов можно было использовать слева от знака 
	// равенства: *MyMin(параметры) = 0;
	{   std::cout << "#8" << std::endl;
		int arr[] = { 108, -7, 90, 45, 38, 76, 3, 5, 2};
		if (*MyMin(arr, sizeof(arr) / sizeof(arr[0])) == 0)
		{
			std::cout << "min zn:" << *MyMin(arr, sizeof(arr) / sizeof(arr[0]));
		}
		else
		{
			std::cout << "Min zn: " << *MyMin(arr, sizeof(arr) / sizeof(arr[0]));
		}
		std::cout << std::endl;
	}
	
	
	return 0;
}//main

